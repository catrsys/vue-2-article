# Уязвимости Vue 2 и смежных пакетов
## Содержание
- [Уязвимости Vue 2 и смежных пакетов](#уязвимости-vue-2-и-смежных-пакетов)
  - [Содержание](#содержание)
  - [Введение](#введение)
  - [Уязвимости фронтенда](#уязвимости-фронтенда)
    - [XSS](#xss)
    - [Prototype Pollution](#prototype-pollution)
    - [CSTI](#csti)
    - [CSRF](#csrf)
    - [ReDOS](#redos)
    - [Open Redirect](#open-redirect)
  - [Что же такое Vue](#что-же-такое-vue)
  - [Уязвимости Vue 2](#уязвимости-vue-2)
    - [XSS](#xss-1)
    - [Open Redirect](#open-redirect-1)
  - [Уязвимости смежных пакетов](#уязвимости-смежных-пакетов)
    - [bootstrap-vue](#bootstrap-vue)
    - [vuetify](#vuetify)
    - [buefy](#buefy)
    - [ajv](#ajv)
    - [hawk](#hawk)
    - [hoek](#hoek)
  - [Рекомендации](#рекомендации)

## Введение
В этой статье я хотела бы рассмотреть уязвимости фреймворка Vue.js второй версии [а также некоторых совместимых с ним пакетов и библиотек] и способы их исправления. По моему скромному опыту, Vue показывает себя как очень лаконичный и приятный инструмент для фронтенд-разработки. Это, в свою очередь, усиливает желание сделать результат разработки как можно более качественным и безопасным.

В настоящий момент Vue.js постепенно [набирает популярность](https://npmtrends.com/angular-vs-react-vs-vue), немногим уступая таким известным JavaScript-фреймворкам и библиотекам, как [React](https://ru.reactjs.org/) и [Angular](https://angular.io/). Несмотря на то, что он начинался как индивидуальный проект, его уже используют многие крупные компании, включая Netflix, Facebook и GitLab.

Статья является обзорной и может быть интересна как фронтенд-разработчикам, желающим познакомиться либо уже знакомым с Vue, так и специалистам по анализу защищенности веб-приложений.

## Уязвимости фронтенда
В [OWASP Top 10 Client-Side Security Risks](https://owasp.org/www-project-top-10-client-side-security-risks/) перечислены наиболее распространенные уязвимости на стороне клиента. Рассмотрим те из них, которые чаще встречаются во Vue и смежных пакетах:
* XSS
* Prototype Pollution
* CSTI
* CSRF
* ReDOS
* Open Redirect

### XSS
Cross-Site Scripting (XSS) – это уязвимость, при которой на страницу внедряется вредоносный JavaScript-код, взаимодействующий с веб-сервером злоумышленника. Злоумышленник может использовать XSS для отправки скрипта ничего не подозревающему пользователю и получить доступ к любым cookie, токенам или другой конфиденциальной информации, сохраненной браузером и используемой на этом сайте, либо переписать сожержимое html-страницы.

В зависимости от места хранения вредоносной нагрузки существуют:
* Хранимые (Stored, Persistent, Type-I) XSS
* Отраженные (Reflected, Non-Persistent, Type-II) XSS
* На основе DOM (DOM-based, Type-0) XSS

В случае **хранимой** XSS внедренный скрипт постоянно хранится на целевых серверах, в базах данных –  например, в отзывах на товар. Жертвами такой атаки могут стать все пользователи, посетившие зараженную страницу. Пример:
```html
<div class="comment">
   <p>I highly recommend this product, 11/10!</p>
   <script src=”http://malicious.com/exploit.js”></script>
</div>
```
Результат **отраженных** XSS сразу возвращается веб-сервером. Отраженные атаки доставляются жертвам по другим каналам, например, по почте. Когда пользователя обманом заставляют щелкнуть вредоносную ссылку, внедренный код перемещается на уязвимый веб-сайт, где браузер выполняет его. Пример ссылки:
```html
https://insecure-website.com/hello?name=<script>alert(1);</script>
<p>Hello, <script>alert(1);</script>!</p>
```
При XSS **на основе DOM** полезная нагрузка атаки выполняется в результате изменения «окружения» DOM в браузере жертвы. HTTP-ответ не меняется, но код на стороне клиента выполняется по-другому из-за вредоносных модификаций, которые произошли в среде DOM. Пример:
```JavaScript
results.innerHTML = 'You searched for: ' + search;
```
```html
http://insecure-website.com/page.html?default=<img+src%3Dx+onerror%3D%27badThings()%3B%27>
<p>You searched for: <img src=x onerror='badThings();'></p>
```

Также XSS делятся на активные и пассивные. Первые, в отличие от вторых, срабатывают без каких-либо действий (переход по ссылке, нажатие на кнопку) со стороны жертвы.

### Prototype Pollution
Эта уязвимость характерна только для JavaScript, поскольку в нем у каждого объекта есть внутреннее свойство `[[Prototype]]`, содержащее ссылку на объект родителя. У родителя, в свою очередь, тоже может быть прототип, у родителя родителя тоже и так далее; последовательность прототипов от объекта до `null` называется цепочкой прототипов или `prototype chain`.

Свойство `prototype` родителя отвечает за те методы и свойства, которые унаследуют все его потомки. При обращении к свойству оно ищется во всей цепочке прототипов. Обратиться к родителю через наследника можно посредством свойств `__proto__`, `Object.getPrototypeOf()` и других.

Термином prototype pollution называют ситуацию, когда изменяют свойство prototype базовых объектов: `Object.prototype`, `Function.prototype`, `Array.prototype`. После исполнения
```JavaScript
Object.prototype.answer = 42;

// или, что то же самое

const obj = new Object();
obj.__proto__.answer = 42;
```
Свойство `answer` со значением 42 будет у любого объекта, если:
* в нем не определено это свойство (иначе оно перекроет свойство прототипа)
* он наследуется от `Object.prototype`

Клиентский prototype pollution чаще всего эскалируется до Reflected XSS, пейлод при этом находится в параметрах запроса (после ?) или в фрагменте (после #). Подробнее можно почитать в [статье на хабре](https://habr.com/ru/company/huawei/blog/547178/) и на [snyk.io](https://learn.snyk.io/lessons/prototype-pollution/javascript/).

### CSTI
Server Side Template Injection (SSTI) происходит, когда злоумышленник может использовать собственный синтаксис шаблона для внедрения вредоносной полезной нагрузки в шаблон, который затем выполняется на стороне сервера. В то время как SSTI позволяет выполнить код на удаленном сервере, Client Side Template Injection (CSTI) позволяет выполнять произвольный код JavaScript на стороне жертвы.

Когда в приложении на AngularJS пользовательский ввод отражается внутри тела HTML, которое определено с помощью директивы `ng-app`
```html
<body ng-app>
```
можно выполнить произвольный JavaScript-код, используя двойные фигурные скобки. Пример нагрузок:
```JavaScript
{{ $on.constructor('alert(1)')() }}
{{ constructor.constructor('alert(1)')() }}
```
CSTI и Prototype Pollution часто называют разновидностями XSS. Подробнее о CSTI можно почитать [тут](https://book.hacktricks.xyz/pentesting-web/client-side-template-injection-csti).

### CSRF
Cross-Site Request Forgery (CSRF) – это атака, которая заставляет пользователя выполнять нежелательные действия в веб-приложении, в котором он в настоящее время аутентифицирован. С помощью социальной инженерии злоумышленник может обманом заставить пользователей веб-приложения действия по выбору злоумышленника.

Если жертва является обычным пользователем, успешная атака CSRF может заставить пользователя выполнять запросы на изменение состояния, такие как перевод средств. Если жертва является административной учетной записью, CSRF может скомпрометировать все веб-приложение.

Пример ссылки:
```html
<a href="http://bank.com/transfer.do?to=evil_hacker&amount=31337">Recieve a Special Offer!</a>
```


### ReDOS
The Regular expression Denial of Service (ReDoS) – атака типа «отказ в обслуживании», которая использует тот факт, что реализации регулярных выражений могут достигать экстремальных ситуаций, которые заставляют их работать очень медленно (в экспоненциальной зависимости от размера входных данных). Злоумышленник может заставить программу, использующую регулярное выражение, войти в эти экстремальные ситуации, чтобы она зависла на очень долгое время.

Пример:
```JavaScript
regex = /A(B|C+)+D/
```
Это регулярное выражение означает следующее:
* строка должна начинаться с 'A'
* затем должна идти буква 'B' или одна или несколько 'C', весь этот сегмент может повторяться
* строка должна заканчиваться символом 'D'

В большинстве случаев движку регулярных выражений не требуется много времени, чтобы найти совпадение, однако, если передать на вход невалидную строку, для завершения теста требуется в десять раз больше времени.  
```JavaScript
time node -e '/A(B|C+)+D/.test("ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX")
```
Существенная разница связана с тем, как оцениваются регулярные выражения.
Движок обычно принимает первый возможный способ интерпретировать текущий символ и переходит к следующему. Если ему не удастся сопоставить следующий, он вернется и посмотрит, есть ли другой способ трактовать предыдущий символ. Если он зайдет слишком далеко только для того, чтобы обнаружить, что строка в конце не совпадает, и если многие символы имеют несколько допустимых интерпретаций, количество шагов возврата может стать очень большим. Это приводит к тому, что известно как **catastrophic backtracking**.

### Open Redirect
Open redirect – брешь в системе безопасности приложения или веб-страницы, из-за которой не удается должным образом аутентифицировать URL-адреса. Когда значения параметра в HTTP GET-запросе позволяет перенаправить пользователя на новый сайт без проверки целевого сайта, открывается возможность для фишинговой атаки, XSS, SSRF или загрузки вредоносных файлов. Пример кода на php:
```php
$redirect_url = $_GET['url'];
header("Location: " . $redirect_url);
```
Вредоносная ссылка дет выглядеть так:
```
http://example.com/example.php?url=http://malicious.example.com
```

## Что же такое Vue
Vue (произносится как “вью”) – это прогрессивный Java-Script фреймворк с [открытым исходным кодом](https://github.com/vuejs/vue) для создания пользовательских интерфейсов и одностраничных веб-приложений.

Прогрессивность подразумевает постепенное внедрение: Vue можно использовать как для части существующего проекта, так и самостоятельно, например, при помощи `@vue/cli`. Разработка Vue.js ведется с 2013 года; первая и вторая версии были выпущены в 2015 и 2016 годах, третья – в 2020. На данный момент из-за того, что большинство библиотек компонентов все еще несовместимы с последней версией, наибольшей популярностью у разработчиков пользуется [Vue 2](https://v2.vuejs.org/).

К основным особенностям фреймворка относятся:
* Декларативный рендеринг
* Реактивность

**Декларативный рендеринг** позволяет отображать данные в DOM, используя простой синтаксис шаблонов. В отличие от императивного стиля, разработчик делегирует детали реализации фреймворку, описывая не то, *что* он должен сделать, а то, *как должен выглядеть* результат.

**Реактивность** означает, что представление в модели MVC изменяется по мере изменения модели: разработчики привязывают представление к соответствующей модели, и Vue автоматически наблюдает за изменениями, обновляя его.

От своих аналогов – Angular и React – Vue отличается простотой и лаконичностью. Ниже представлен [базовый пример](https://scrimba.com/scrim/cQ3QVcr?pl=pXKqta) приложения на Vue 2:

index.html
```html
<html>
    <head>
        <link rel="stylesheet" href="index.css">
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    </head>
    <body>
        
        <div id="app">
            {{ message }}
        </div>
        
        <script src="index.js"></script>
    </body>
</html>
```
index.js
```js
var app = new Vue({ 
    el: '#app',
    data: {
        message: 'Hello Vue!'
    }
});
```
index.css
```css
html, body {
    margin: 5px;
    padding: 0;
}
```
В примере выше компонент `app`, соответствующий элементу с таким же `id`, создается при помощи `Vue.component`. В больших проектах или когда интерфейс полностью основан на JavaScript, компоненты удобнее оформлять в стиле [single-file components](https://v2.vuejs.org/v2/guide/single-file-components.html), где каждый из них – это файл с расширением `.vue`. Структура таких файлов состоит из трех частей:
* блок `<template>`, отвечающий за html-шаблон компонент (является обязательным и содержит только один корневой компонент)
* блок `<script>`, отвечающий за логику и содержащий состояние компонента (в примере – `data`)
* блок `<style>`, отвечающий за стили

То есть вместо того, чтобы делить все приложение на три слоя (файлы `.html`, `.js`, `.css`), оно разбивается на компоненты, внутри которых сохраняется то же разделение.

Базовый пример в таком стиле выглядит [следующим образом](https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-single-file-components):

index.html
```html
<div id="app"></div>
```
index.js
```js
import Vue from "vue";
import App from "./Hello";

Vue.config.productionTip = false;

new Vue({
  el: "#app",
  template: "<App/>",
  components: { App }
});

```
Hello.vue
```js
<template>
  <p>{{ greeting }} World!</p>
</template>

<script>
module.exports = {
  data: function() {
    return {
      greeting: "Hello"
    };
  }
};
</script>

<style scoped>
p {
  font-size: 2em;
  text-align: center;
}
</style>
```
Для того, чтобы добавить реактивность в проект на Vue, можно воспользоваться входными параметрами, вычисляемыми свойствами компонентов, директивами, событиями, наблюдателями и т.д.

Входные параметры `props` – пользовательские атрибуты, устанавливаемые на компоненте. Когда значение передаётся в атрибут входного параметра, оно становится свойством экземпляра компонента, как `data` в примере. Вычисляемые свойства используются для переноса сложной логики из шаблона в свойство `computed`, которое, в отличие от обычного метода, пересчитывается только в случае изменения зависимостей. [Директивы](https://ru.vuejs.org/v2/api/#%D0%94%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B) – это команды, обрабатываемые Vue, и записанные как аттрибуты HTML-тэгов. Обычно директивы Vue начинаются с префикса `v-`. Некоторым директивам можно передавать дополнительные аргументы через двоеточие:
* `v-text` управляет текстовым содержимым элемента
* `v-html` управляет HTML-содержимым элемента, что может привести к XSS при передаче пользовательского ввода
* `v-show` переключает CSS-свойство `display` элемента, в зависимости от того, истинно ли указанное выражение
* `v-on` (сокращается как '@') устанавливает обработчик события, переданного как аргумент
* `v-bind` (сокращается как ':') отвечает за реактивную привязку атрибута к значению свойства
* `v-model` создает двухстороннюю связь элемента и свойства
* `v-if` и `v-else` отвечают за условный рендеринг элементов в зависимости от значения переданного аргумента
* `v-for` осуществляет рендеринг набора элементов, основываясь на переданных данных. Для тех, кто уже знаком с React, пример может выглядеть так:

React
```js
this.state.data.map((item, i) => <div key={item.id}>item.text</div>)
```
Vue
```html
<div v-for=”(item, index) in items” :key=”item.id”>{{ item.text }}</div>
```

Vue предоставляет разработчику множество возможностей:
* роутинг при помощи библиотеки `Vue-router`
* управление состоянием при помощи `Vuex`
* отрисовка на стороне сервера

Для того, чтобы увидеть все это действии, можно посмотреть небольшой проект [TodoMVC](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-todomvc?from-embed), либо построенный на Firebase API, Vue 2.0 + Vue Router + Vuex [Клон HackerNews](https://github.com/vuejs/vue-hackernews-2.0), компоненты которого описаны в стиле SFC. Узнать больше о самом Vue 2, особенностях, примерах и способах его использования можно в [официальной документации](https://v2.vuejs.org/v2/guide/).

## Уязвимости Vue 2
https://ru.vuejs.org/v2/guide/security.html

### XSS

### Open Redirect



Демо XSS в Vue.js [7] показывает, что XSS может появиться на странице, где используется директива v-html. Она позволяет парсить HTML из небезопасного пользовательского ввода [8], встраивая на страницу произвольный код.

CSRF во Vue.js возможна тогда, когда при разработке не используется библиотек для формирования и проверки CSRF-токенов, позволяющих однозначно установить, был ли запрос совершен пользователем со страницы веб-ресурса или кем-то от его имени.


## Уязвимости смежных пакетов

### bootstrap-vue

### vuetify

### buefy

### ajv

### hawk

### hoek

## Рекомендации
Так как XSS обусловлено использованием директивы v-html, существует несколько подходов по ее устранению:
* выключить парсинг HTML, подставляя сообщения на страницу так, как есть: ```<p>{{ message.text }}</p>```;
* в случае, если парсинг HTML необходим – санитизировать пользовательский ввод при помощи пакета sanitize-html: ```<p v-html="sanitizeHtml(message.text)"></p>```;
* настроить Content Security Policy, которая будет обеспечивать безопасность всей платформы и послужит последней линией защиты.

CSRF устраняется добавлением csrf-токенов (модуль csurf).

Источники
1. https://docs.google.com/document/d/1ko_wmO_MO5hh1GE5j0qqz4I9NCnKEAA9H86z2vjr7s4/edit#
2. XSS demo using Vue — URL: https://github.com/sqreen/VueXSSDemo
3. XSS in Vue.js — https://blog.sqreen.com/xss-in-vue-js/
4. Vue CSRF Protection Guide: CSRF Examples and How to Enable Protection. — https://www.stackhawk.com/blog/vue-csrf-protection-guide-csrf-examples-and-how-to-enable-protection/
5. Впечатления о Vue.js после React — https://habr.com/ru/post/534206/
6. https://ru.vuejs.org/v2/guide/security.html

